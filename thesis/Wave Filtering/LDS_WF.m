%%% This script calculates the one step prediction using the Spectral
%%% Filtering for Linear Dynamical Systems as by Hazan et al. (2017)[1].
%%% The data is generated by a random stable bounded LDS. All parameters
%%% can be adjusted. 
% 1) https://arxiv.org/abs/1711.00946
clear
close all
clc
set(0,'DefaultLineLineWidth',2);
warning off
%% Demo parameters
system = 1;             % Use predefined system (otherwise random)
input = 1;              % Use predefined input  (otherwise random)
%% System parameters
n = 2;                  % Input size
m = 1;                  % Output size
nh = 2;                 % Hidden states
Rx = 1;                 % Input bound
Ry = 10;                % Output bound
Rm = 2;                % Spectral bound on M
Rlds = 0.1;               % Spectral bound on system
L = 1000;               % Noise 'budget'
T = 5000;               % Time horizon
k = 5;                 % Filter size
% Learning rate
N = 500/(Rx^2*Ry*log(Rm*Rx*Ry*n)*n*sqrt(T)*log(T)^4);                
ks = n*k + 2*n + m;     % Filtered state size
%% Generate data
% A,B,C,D are random integer matrices with max of maxi and normalized
% according to the Frobenius (spectral) norm. The input sequence X is drawn
% from a Gaussian distribution of which 99.7% (3 sigma) lays within Rx. 
maxi = 10;
A = randi(maxi,nh,nh); [~,S,~] = svd(A); s = sqrt(sum(sum(S.^2))); A = A/s;
if any(abs(eig(A))) > 1; error('Produced A Matrix not Lyapunov stable'); end
if any(abs(eig(A))) > 0.9; warning('Produced A Matrix close to instability'); end
B = randi(maxi,nh,n); [~,S,~] = svd(B); s = sqrt(sum(sum(S.^2))); B = Rlds/s*B;
C = randi(maxi,m,nh); [~,S,~] = svd(C); s = sqrt(sum(sum(S.^2))); C = Rlds/s*C;
D = randi(maxi,m,n); [~,S,~] = svd(D); s = sqrt(sum(sum(S.^2))); D = Rlds/s*D;
if system
    A = [0.990 0;0 0.5];
    B = [1;1];
    C = [1 1];
    D = 0;
    n=1;
    m=1;
    nh=2;
    ks = n*k + 2*n + m;
end
    
x = mvnrnd(zeros(n,1),eye(n)*Rx/3^2,T)';     
if input
    z = 50;     % Amount of intervals
    o = 1;      % Max action
   for i=1:z
       zt = 2*o*(rand-0.5);
       x(T/z*(i-1)+1:T/z*i) = zt;
   end
end
eps = mvnrnd(0,L/2/3^2,T);
eta = mvnrnd(0,L/2/3^2,T);
Lr = sum(abs(eps).^2+abs(eta).^2);
eps = L/Lr*eps; eta = L/Lr*eta;
h = randi(maxi,nh,1); h = h/sum(h.^2);
h_r = h;
y(:,1) = C*h(:,1);
for t =1:T-1
    h(:,t+1) = A*h(:,t) + B*x(:,t) + eta(t);
    y(:,t+1) = C*h(:,t) + D*x(:,t) + eps(t);
    h_r(:,t+1) = A*h_r(:,t) + B*x(:,t);
    y_r(:,t+1) = C*h_r(:,t) + D*x(:,t);
end
%% Compute filter values
Z = zeros(T,T);
for i =1:T
    for j =1:T
        Z(i,j) = 2/((i+j)^3-(i+j));
    end
end
[V,E] = eig(Z);
[~,ind] = sort(diag(E),'descend');
E = diag(E(ind,ind));
V = V(:,ind);
sig = E(1:k);
phi = V(:,1:k);
%% Online Spectral Filter LDS 
tic;
M(:,:,2) = zeros(m,ks);
SE(1) = 0;
for t=2:T
    for i =1:n
        for j=1:k
            X(i,j) = sig(j)^0.25*sum(phi(1:t,j).*flipud(x(i,1:t)'));
        end
    end
    Xt = [reshape(X,n*k,1);x(:,t-1);x(:,t);y(:,t-1)];
    yp(:,t) = M(:,:,t)*Xt;
    M(:,:,t+1) = M(:,:,t) + 2*N*(y(:,t) - yp(:,t))*Xt';
    [~,S,~] = svd(M(:,:,t+1));
    if sqrt(sum(sum(S.^2))) > Rm
        M(:,:,t+1) = M(:,:,t+1)*Rm/sqrt(sum(sum(S.^2)));
    end
    MSE(t) = sum((y_r(:,t)-yp(:,t)).^2);
    SE(t) = SE(t-1) + MSE(t);
end
time = toc;
fprintf('Spectral Filter iteration %.2f ms to compute\n',time/T*1000)
%% Compare to N4sid (given amount of states)
tic;
DAT = iddata(y',x');
sys = n4sid(DAT,nh);
Yp2 = lsim(sys,x',linspace(1,T,T));
time = toc;
fprintf('N4SID took %.2f ms to compute\n',time*1000)
MSE2 = sum((y_r-Yp2').^2,1);
%% Visualize
figure
plot(reshape(M(1,2,1:1000),1,1000))
title('Convergence of M')
figure
plot(y_r')
hold on
plot(yp')
plot(Yp2')
% plot(y)
legend('Data','Spectral','N4SID')
title('Output and prediction')
figure
z = 100;
semilogy(movmean(MSE,z))
hold on
semilogy(movmean(MSE2,z))
legend('Spectral','N4SID')
title('Estimation error')